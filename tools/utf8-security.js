#!/bin/env node
var http = require('http');
var fs = require('fs');

process.stderr.write("downloading data\n");

var downloadFn = function(url, completeFn) {
	var data = "";
	http.get(url, function(res) {
		res.setEncoding("utf8");
		res.on("data", function(chunk) {
			data += chunk;
		});
		res.on("end", function() {
			completeFn(data);
		});
	}).on("error", function(e) {
		throw e;
	});
};

var files = {};

(function() {
	downloadFn("http://www.unicode.org/Public/security/latest/confusables.txt", function(data) {
		files.conf = data;
		genMapFunction();
	});
	downloadFn("http://www.unicode.org/Public/security/latest/xidmodifications.txt", function(data) {
		files.xid = data;
		genMapFunction();
	});
})();

var codePrefix = '\// This code is auto-generated by /tools/utf8-security.js.\n' +
				 '\// Do not change it manually.\n#include "rcd.h"\n\n';

var genMapFunction = function() {
	if (Object.keys(files).length < 2)
		return;
	// Iterate over confusable data and build c_map.
	process.stderr.write("generating confusable c_map\n");
	var c_map = {};
	files.conf.split("\n").forEach(function(line, i) {
		line = line.trim().replace(/#.*$/, "").trim();
		if (line.length === 0) {
			return;
		}

		var m = line.match(/^([^;]+);([^;]+);\s*([A-Z]{2,2})$/);
		if (!m) {
			throw("parsing line failed [" + line + "]");
		}
		var inChr = m[1].trim().split(/\s+/);
		var outChrs = m[2].trim().split(/\s+/);
		var table = m[3];

		if (table !== "SL" && table !== "SA" && table !== "ML" && table !== "MA") {
			throw("unknown table found: " + line);
		}
		if (inChr.length != 1) {
			throw("expected 1 input, found " + inChr.length + ": " + line);
		}
		if (outChrs.length === 0) {
			throw("expected 1 output or more, found " + outChrs.length + ": " + line);
		}

		if (table !== "MA") {
			// For now we ignore all tables except MA (Mixed-Script, Any-Case) as the tables
			// are very large and the other tables having very limited practical use.
			return;
		}

		var inChrN = parseInt(inChr, 16);
		var outChrsN = [];
		outChrs.forEach(function (outChr) {
			var outChrN = parseInt(outChr, 16);
			outChrsN.push(outChrN);
		});

		table = table.toLowerCase();
		if (!c_map[table]) {
			c_map[table] = {};
		}
		if (c_map[table][inChrN]) {
			throw("more than one inputs of " + inChr + " found");
		}
		c_map[table][inChrN] = outChrsN;
	});
	// Iterate over xid data.
	process.stderr.write("generating xid c_map\n");
	var xid_ranges = [];
	files.xid.split("\n").forEach(function(line, i) {
		line = line.trim().replace(/#.*$/, "").trim();
		if (line.length === 0) {
			return;
		}

		var m = line.match(/^([^;]+);([^;]+);([^;]+)$/);
		if (!m) {
			throw("parsing line failed [" + line + "]");
		}
		var range = m[1].trim().match(/^([0-9A-F]+)(\.\.([0-9A-F]+))?$/);
		var status = m[2].trim().replace(/-/g, '_').toLowerCase();
		var type = m[3].trim().replace(/-/g, '_').toLowerCase();

		if (!range) {
			throw("failed to parse range of line: " + line);
		}
		if (status.length === 0 || type.length === 0) {
			throw("missing status/type");
		}

		var start = parseInt(range[1], 16);
		var end = range[3]? parseInt(range[3], 16): null;

		xid_ranges.push({
			start: start,
			end: end,
			status: status,
			type: type
		});
	});

	// Generate code.
	process.stderr.write("generating code\n");

	var code = codePrefix;

	for (var table in c_map) {
		code += 'bool utf8_confusable_' + table + '(uint32_t in_chr, const uint32_t* out_chrv[], uint8_t* out_len) {\n' +
			    '    switch (in_chr) {{\n';
		var table_map = c_map[table];
		for (var inChrN in table_map) {
			var outChrsN = table_map[inChrN];
			for (var i = 0; i < outChrsN.length; i++) {
				outChrsN[i] = outChrsN[i].toString(16);
			}

			code += '    } case 0x' + Number(inChrN).toString(16) + ': {\n' +
					'        static const uint32_t out[] = {0x' + outChrsN.join(", 0x") + "};\n" +
					'        *out_chrv = out;\n' +
					'        *out_len = ' + outChrsN.length + ';\n' +
					'        return true;\n';
		}
		code += '    }}\n' +
				'    return false;\n' +
				'}\n' +
				'\n';
	}

	code += 'void utf8_xid_modification(uint32_t in_chr, utf8_xid_status_t* out_status, utf8_xid_type_t* out_type) {\n' +
		'    switch (in_chr) {{\n';
	for (var i = 0; i < xid_ranges.length; i++) {
		var entry = xid_ranges[i];
		code += '    } case 0x' + entry.start.toString(16) + (entry.end !== null? " ... 0x" + entry.end.toString(16): "") + ': {\n' +
				'        *out_status = utf8_xid_' + entry.status + ';\n' +
				'        *out_type = utf8_xid_' + entry.type + ';\n' +
				'        return;\n';
	}
	code += '    }}\n' +
			'    *out_status = utf8_xid_restricted;\n' +
			'    *out_type = utf8_xid_not_chars;\n' +
			'}\n' +
			'\n';

	// Write code to stdout.
	process.stderr.write("writing code\n");
	process.stdout.write(code);
	process.stderr.write("done\n");
	process.exit(0);
};
